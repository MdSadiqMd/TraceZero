/// Zero values are pre-computed using Poseidon hash to match the circuit exactly. These MUST match circuits/withdrawal.circom
use crate::crypto::poseidon_hash;
use crate::error::{Result, SdkError};
use once_cell::sync::Lazy;
use serde::{Deserialize, Serialize};

/// Merkle tree depth (supports 2^20 = ~1M deposits per pool)
pub const TREE_DEPTH: usize = 20;

/// Pre-computed zero values for empty tree nodes using Poseidon hash
/// zeros[i] = hash of empty subtree at depth i
/// Generated by: node circuits/scripts/compute_zeros.js
///
/// These values MUST match the circuit's zero values exactly.
/// Level 0: [0u8; 32] (zero leaf)
/// Level n: Poseidon(level_{n-1}, level_{n-1})
static ZEROS: Lazy<[[u8; 32]; TREE_DEPTH + 1]> = Lazy::new(compute_zeros_runtime);

/// Merkle proof for a leaf
#[derive(Clone, Serialize, Deserialize, Debug)]
pub struct MerkleProof {
    /// Sibling hashes along the path
    pub siblings: Vec<[u8; 32]>,
    /// Path indices (0 = left, 1 = right)
    pub path_indices: Vec<u8>,
    /// Leaf index in the tree
    pub leaf_index: u64,
}

/// Sparse Merkle tree
pub struct MerkleTree {
    /// Tree depth
    depth: usize,
    /// Leaves (commitments)
    leaves: Vec<[u8; 32]>,
    /// Internal nodes by level (level 0 = leaves)
    nodes: Vec<Vec<[u8; 32]>>,
}

impl MerkleTree {
    pub fn new(depth: usize) -> Result<Self> {
        if depth > TREE_DEPTH {
            return Err(SdkError::MerkleTree(format!(
                "Depth {} exceeds maximum {}",
                depth, TREE_DEPTH
            )));
        }

        Ok(Self {
            depth,
            leaves: Vec::new(),
            nodes: vec![Vec::new(); depth + 1],
        })
    }

    pub fn insert(&mut self, leaf: [u8; 32]) -> Result<u64> {
        let index = self.leaves.len() as u64;
        if index >= (1u64 << self.depth) {
            return Err(SdkError::MerkleTree("Tree is full".into()));
        }

        self.leaves.push(leaf);
        self.update_path(index as usize);

        Ok(index)
    }

    pub fn root(&self) -> Result<[u8; 32]> {
        if self.leaves.is_empty() {
            return Ok(ZEROS[self.depth]);
        }
        self.compute_root()
    }

    pub fn proof(&self, leaf_index: u64) -> Result<MerkleProof> {
        if leaf_index >= self.leaves.len() as u64 {
            return Err(SdkError::MerkleTree("Leaf index out of bounds".into()));
        }

        // First, compute all internal nodes needed for the proof
        let mut current_level: Vec<[u8; 32]> = self.leaves.clone();

        // Pad to next power of 2 with zeros
        let next_pow2 = current_level.len().next_power_of_two();
        while current_level.len() < next_pow2 {
            current_level.push(ZEROS[0]);
        }

        // Store all levels for proof generation
        let mut all_levels: Vec<Vec<[u8; 32]>> = vec![current_level.clone()];
        for level in 0..self.depth {
            if current_level.len() <= 1 {
                for remaining_level in level..self.depth {
                    all_levels.push(vec![ZEROS[remaining_level]]);
                }
                break;
            }

            let mut next_level = Vec::with_capacity((current_level.len() + 1) / 2);
            for chunk in current_level.chunks(2) {
                let left = chunk[0];
                let right = chunk.get(1).copied().unwrap_or(ZEROS[level]);
                next_level.push(hash_pair(&left, &right)?);
            }

            current_level = next_level.clone();
            all_levels.push(next_level);
        }

        // Now generate the proof using the computed levels
        let mut siblings = Vec::with_capacity(self.depth);
        let mut path_indices = Vec::with_capacity(self.depth);
        let mut current_index = leaf_index as usize;

        for level in 0..self.depth {
            let sibling_index = current_index ^ 1;
            let sibling = if level < all_levels.len() && sibling_index < all_levels[level].len() {
                all_levels[level][sibling_index]
            } else {
                ZEROS[level]
            };

            siblings.push(sibling);
            path_indices.push((current_index & 1) as u8);

            current_index >>= 1;
        }

        Ok(MerkleProof {
            siblings,
            path_indices,
            leaf_index,
        })
    }

    pub fn verify_proof(root: &[u8; 32], leaf: &[u8; 32], proof: &MerkleProof) -> Result<bool> {
        let mut current = *leaf;
        for (sibling, &path_index) in proof.siblings.iter().zip(proof.path_indices.iter()) {
            current = if path_index == 0 {
                hash_pair(&current, sibling)?
            } else {
                hash_pair(sibling, &current)?
            };
        }

        Ok(&current == root)
    }

    pub fn len(&self) -> usize {
        self.leaves.len()
    }

    pub fn is_empty(&self) -> bool {
        self.leaves.is_empty()
    }

    fn update_path(&mut self, leaf_index: usize) {
        let mut current_index = leaf_index;
        for level in 0..self.depth {
            // Ensure the level has enough capacity
            while self.nodes[level].len() <= current_index {
                self.nodes[level].push(ZEROS[level]);
            }

            // Update node at this level
            if level == 0 {
                self.nodes[level][current_index] = self.leaves[leaf_index];
            }

            current_index >>= 1;
        }
    }

    #[allow(dead_code)]
    fn get_node(&self, level: usize, index: usize) -> [u8; 32] {
        if level == 0 {
            self.leaves.get(index).copied().unwrap_or(ZEROS[0])
        } else if let Some(node) = self.nodes[level].get(index) {
            *node
        } else {
            ZEROS[level]
        }
    }

    fn compute_root(&self) -> Result<[u8; 32]> {
        if self.leaves.is_empty() {
            return Ok(ZEROS[self.depth]);
        }

        let mut current_level: Vec<[u8; 32]> = self.leaves.clone();

        // Pad to next power of 2 with zeros
        let next_pow2 = current_level.len().next_power_of_two();
        while current_level.len() < next_pow2 {
            current_level.push(ZEROS[0]);
        }

        for level in 0..self.depth {
            if current_level.len() == 1 {
                current_level = vec![hash_pair(&current_level[0], &ZEROS[level])?];
            } else {
                let mut next_level = Vec::with_capacity((current_level.len() + 1) / 2);
                for chunk in current_level.chunks(2) {
                    let left = chunk[0];
                    let right = chunk.get(1).copied().unwrap_or(ZEROS[level]);
                    next_level.push(hash_pair(&left, &right)?);
                }
                current_level = next_level;
            }

            if current_level.len() == 1 && level == self.depth - 1 {
                break;
            }
        }

        Ok(current_level[0])
    }
}

fn hash_pair(left: &[u8; 32], right: &[u8; 32]) -> Result<[u8; 32]> {
    poseidon_hash(&[left, right])
}

/// Compute zero values at runtime using Poseidon hash
/// This ensures the values match the circuit exactly
fn compute_zeros_runtime() -> [[u8; 32]; TREE_DEPTH + 1] {
    let mut zeros = [[0u8; 32]; TREE_DEPTH + 1];

    // Level 0: zero leaf (all zeros)
    zeros[0] = [0u8; 32];

    // Each subsequent level: Poseidon(prev_level, prev_level)
    for i in 1..=TREE_DEPTH {
        zeros[i] = poseidon_hash(&[&zeros[i - 1], &zeros[i - 1]])
            .expect("Poseidon hash should not fail for valid inputs");
    }

    zeros
}

pub fn get_zero_value(level: usize) -> Result<[u8; 32]> {
    if level > TREE_DEPTH {
        return Err(SdkError::MerkleTree(format!(
            "Level {} exceeds tree depth {}",
            level, TREE_DEPTH
        )));
    }
    Ok(ZEROS[level])
}

pub fn get_all_zeros() -> &'static [[u8; 32]; TREE_DEPTH + 1] {
    &ZEROS
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::crypto::random_secret;

    #[test]
    fn test_merkle_tree_basic() {
        let mut tree = MerkleTree::new(4).unwrap();

        // Use field-safe values
        let leaf1 = random_secret();
        let leaf2 = random_secret();

        let idx1 = tree.insert(leaf1).unwrap();
        let idx2 = tree.insert(leaf2).unwrap();

        assert_eq!(idx1, 0);
        assert_eq!(idx2, 1);
        assert_eq!(tree.len(), 2);
    }

    #[test]
    fn test_merkle_proof() {
        let mut tree = MerkleTree::new(4).unwrap();

        // Use field-safe value
        let leaf = random_secret();
        let idx = tree.insert(leaf).unwrap();

        let root = tree.root().unwrap();
        let proof = tree.proof(idx).unwrap();

        assert!(MerkleTree::verify_proof(&root, &leaf, &proof).unwrap());
    }
}
