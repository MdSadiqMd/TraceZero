#!/bin/bash
# Export Verifying Key for Solana Program
#
# Converts the snarkjs verification key JSON to Rust constants
# for use in the zk_verifier Anchor program.
#
# Usage: ./scripts/export_vk.sh [circuit_name]

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CIRCUITS_DIR="$(dirname "$SCRIPT_DIR")"
BUILD_DIR="$CIRCUITS_DIR/build"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

CIRCUIT_NAME="${1:-withdrawal}"
VK_FILE="$BUILD_DIR/keys/${CIRCUIT_NAME}_verification_key.json"
OUTPUT_FILE="$CIRCUITS_DIR/build/${CIRCUIT_NAME}_vk.rs"

echo -e "${GREEN}=== Export Verifying Key to Rust ===${NC}"

if [ ! -f "$VK_FILE" ]; then
    echo -e "${RED}Error: Verification key not found: $VK_FILE${NC}"
    echo "Run setup.sh first"
    exit 1
fi

# Use Node.js to parse and convert
node << 'EOF' > "$OUTPUT_FILE"
const fs = require('fs');
const vkFile = process.argv[2] || 'build/keys/withdrawal_verification_key.json';

const vk = JSON.parse(fs.readFileSync(vkFile, 'utf8'));

// Helper to convert hex string to byte array
function hexToBytes(hex) {
    if (hex.startsWith('0x')) hex = hex.slice(2);
    const bytes = [];
    for (let i = 0; i < hex.length; i += 2) {
        bytes.push(parseInt(hex.substr(i, 2), 16));
    }
    return bytes;
}

// Helper to convert G1 point (2 field elements) to 64 bytes
function g1ToBytes(point) {
    const x = BigInt(point[0]).toString(16).padStart(64, '0');
    const y = BigInt(point[1]).toString(16).padStart(64, '0');
    return [...hexToBytes(x), ...hexToBytes(y)];
}

// Helper to convert G2 point (2x2 field elements) to 128 bytes
function g2ToBytes(point) {
    // G2 points have nested arrays: [[x0, x1], [y0, y1]]
    const x0 = BigInt(point[0][0]).toString(16).padStart(64, '0');
    const x1 = BigInt(point[0][1]).toString(16).padStart(64, '0');
    const y0 = BigInt(point[1][0]).toString(16).padStart(64, '0');
    const y1 = BigInt(point[1][1]).toString(16).padStart(64, '0');
    return [...hexToBytes(x0), ...hexToBytes(x1), ...hexToBytes(y0), ...hexToBytes(y1)];
}

// Format bytes as Rust array
function formatBytes(bytes, name, size) {
    const lines = [];
    lines.push(`pub const ${name}: [u8; ${size}] = [`);
    for (let i = 0; i < bytes.length; i += 16) {
        const chunk = bytes.slice(i, i + 16);
        lines.push('    ' + chunk.map(b => '0x' + b.toString(16).padStart(2, '0')).join(', ') + ',');
    }
    lines.push('];');
    return lines.join('\n');
}

// Generate Rust code
let output = `//! Auto-generated verifying key for ${process.argv[2] || 'withdrawal'} circuit
//! Generated by export_vk.sh - DO NOT EDIT MANUALLY
//!
//! To regenerate: ./scripts/export_vk.sh

`;

// Alpha G1 (64 bytes)
const alphaG1 = g1ToBytes(vk.vk_alpha_1);
output += formatBytes(alphaG1, 'ALPHA_G1', 64) + '\n\n';

// Beta G2 (128 bytes)
const betaG2 = g2ToBytes(vk.vk_beta_2);
output += formatBytes(betaG2, 'BETA_G2', 128) + '\n\n';

// Gamma G2 (128 bytes)
const gammaG2 = g2ToBytes(vk.vk_gamma_2);
output += formatBytes(gammaG2, 'GAMMA_G2', 128) + '\n\n';

// Delta G2 (128 bytes)
const deltaG2 = g2ToBytes(vk.vk_delta_2);
output += formatBytes(deltaG2, 'DELTA_G2', 128) + '\n\n';

// IC points (64 bytes each)
output += `/// Number of public inputs\n`;
output += `pub const NUM_PUBLIC_INPUTS: usize = ${vk.IC.length - 1};\n\n`;

for (let i = 0; i < vk.IC.length; i++) {
    const ic = g1ToBytes(vk.IC[i]);
    output += formatBytes(ic, `IC_${i}`, 64) + '\n\n';
}

// Helper function
output += `/// Get all IC points as a slice reference
pub fn get_ic_points() -> &'static [[u8; 64]] {
    &[${vk.IC.map((_, i) => `IC_${i}`).join(', ')}]
}
`;

console.log(output);
EOF

echo -e "${GREEN}âœ“ Exported to: ${OUTPUT_FILE}${NC}"
echo -e "\nCopy this file to: programs/privacy_proxy/programs/zk_verifier/src/verifying_key.rs"
