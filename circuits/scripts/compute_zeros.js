#!/usr/bin/env node
/**
 * Compute Poseidon zero values for Merkle tree
 *
 * These values MUST be used in:
 * - programs/privacy_proxy/programs/privacy_proxy/src/instructions/deposit.rs
 * - app/src/lib/crypto/poseidon.ts
 * - crates/privacy-proxy-sdk/src/merkle.rs
 *
 * Run: node scripts/compute_zeros.js
 */

const { buildPoseidon } = require("circomlibjs");

async function main() {
  const poseidon = await buildPoseidon();
  const F = poseidon.F;

  const MERKLE_TREE_DEPTH = 20;
  const zeros = [];

  // Level 0: zero leaf (all zeros)
  let current = F.zero;
  zeros.push(current);

  console.log("// Precomputed Poseidon zero values for Merkle tree");
  console.log("// Generated by: node scripts/compute_zeros.js");
  console.log("");
  console.log("const MERKLE_ZERO_VALUES: [[u8; 32]; MERKLE_TREE_DEPTH] = [");

  for (let i = 0; i < MERKLE_TREE_DEPTH; i++) {
    const bytes = toBytes32(F.toObject(current));
    const hexStr = bytes
      .map((b) => `0x${b.toString(16).padStart(2, "0")}`)
      .join(", ");

    console.log(
      `    // Level ${i}${i === 0 ? ": zero leaf" : `: Poseidon(level${i - 1}, level${i - 1})`}`,
    );
    console.log(`    [${hexStr.slice(0, 80)}`);
    console.log(`     ${hexStr.slice(80)}],`);

    // Compute next level: Poseidon(current, current)
    current = poseidon([current, current]);
  }

  console.log("];");

  // Also output TypeScript version
  console.log("\n\n// TypeScript version:");
  console.log("export const MERKLE_ZERO_VALUES: bigint[] = [");

  current = F.zero;
  for (let i = 0; i < MERKLE_TREE_DEPTH; i++) {
    const value = F.toObject(current);
    console.log(`  ${value}n, // Level ${i}`);
    current = poseidon([current, current]);
  }

  console.log("];");
}

function toBytes32(bigint) {
  const hex = bigint.toString(16).padStart(64, "0");
  const bytes = [];
  for (let i = 0; i < 64; i += 2) {
    bytes.push(parseInt(hex.slice(i, i + 2), 16));
  }
  return bytes;
}

main().catch(console.error);
